extended_explain -- расширение для СУБД PostgreSQL, позволяющее исследовать все пути (узлы), которые оптимизатор/планировщик перебирает в процессе поиска наилучшего плана исполнения запроса. 

Содержание:

1. [Инсталляция](#инсталляция)
     1. [make](#make)
     2. [meson](#meson)
2. [Примеры использования](#примеры-использования)
3. [Тесты](#тесты)

# Инсталляция

Перед инсталляцией необходимо применить патч для postgres-а. В репозитории есть два патча: 
1. after_24225ad9aaf.patch - для postgres-а после патча 24225ad9aaf включительно
2. before_24225ad9aaf.patch - для postgres-a до патча 24225ad9aaf

```sh
git apply patch_name.patch
```

Инсталлировать расширение можно двумя способами: с помощью make и meson.

## make
```sh
make install
```    
Если переменная окружения PATH не определена:
```sh
make PG_CONFIG=postgres_directory/bin/pg_config install
```
## meson 
```sh
meson build
cd build
ninja install
```
Если переменная окружения PATH не определена:
```sh
meson build -Dpg_config=postgres_directory/bin/pg_config
cd build
ninja install
```

### Создание расширения

Добавляем расширение в shared_preload_libraries в конфигурационном файле postgresql.conf:
```
shared_preload_libraries = 'extended_explain'
```

Далее создаем расширение посредством терминального клиента psql.
```sql
CREATE EXTENSION extended_explain;
```

# Примеры использования

При каждом вызове команды EXPLAIN с параметром get_paths в таблицу ee.paths будут записываться все пути, которые оптимизатор запросов рассматривал при поиске лучшего плана исполнения SQL запроса. Помимо этого в таблицу ee.query будет записана общая инфомрация об исполннеии команды EXPLAIN.

В качестве примера рассмотрим запрос с соединением двух таблиц t1 и t2, каждая из которых имеет по одному столбцу типа integer. Также на столбец таблицы t1 "навесим" btree индекс.
```sql
CREATE TABLE t1 AS SELECT generate_series(1,1000) AS att;
CREATE INDEX ON t1(att);

CREATE TABLE t2 AS SELECT generate_series(1,10000) att;
```

Выполним команду EXPLAIN для запроса с соединением:

```sql
EXPLAIN (get_paths) SELECT * FROM t1 JOIN t2 ON t1.att = t2.att;
                            QUERY PLAN                            
------------------------------------------------------------------
 Hash Join  (cost=30.50..482.10 rows=16320 width=8)
   Hash Cond: (t2.att = t1.att)
   ->  Seq Scan on t2  (cost=0.00..227.20 rows=16320 width=4)
   ->  Hash  (cost=18.00..18.00 rows=1000 width=4)
         ->  Seq Scan on t1  (cost=0.00..18.00 rows=1000 width=4)
(5 rows)
```

После завершения исполнения команды все пути сохраняются в таблицу расширения ee.paths:

```sql
SELECT * FROM ee.paths;
 query_id | subquery_type | subquery_id | rel_id | path_id |   path_type    | child_paths |    startup_cost    |     total_cost     | rows  | is_del | rel_name | indexoid | joined_rel_num 
----------+---------------+-------------+--------+---------+----------------+-------------+--------------------+--------------------+-------+--------+----------+----------+----------------
        1 |               |           1 |      1 |       1 | SeqScan        |             |                  0 |                 18 |  1000 | f      | t1       |          |              1
        1 |               |           1 |      1 |       2 | IndexOnlyScan  |             |              0.275 |             46.275 |  1000 | f      | t1       |    50414 |              1
        1 |               |           1 |      1 |       3 | IndexOnlyScan  |             |              0.275 | 0.2956862745098039 |     1 | f      | t1       |    50414 |              1
        1 |               |           1 |      1 |       4 | BitmapHeapScan |             | 0.2839754901960784 |  4.296475490196078 |     1 | f      | t1       |          |              1
        1 |               |           1 |      2 |       5 | SeqScan        |             |                  0 | 227.20000000000002 | 16320 | f      | t2       |          |              1
        1 |               |           1 |      3 |       6 | MergeJoin      | {1,5}       |  1436.968161870994 |  1686.768161870994 | 16320 | f      |          |          |              2
        1 |               |           1 |      3 |       7 | MergeJoin      | {2,5}       | 1369.4142404476836 | 1662.7142404476836 | 16320 | f      |          |          |              2
        1 |               |           1 |      3 |       8 | HashJoin       | {1,5}       | 431.20000000000005 | 2654.8999999999996 | 16320 | f      |          |          |              2
        1 |               |           1 |      3 |       9 | MergeJoin      | {5,1}       |  1436.968161870994 | 1763.3681618709938 | 16320 | f      |          |          |              2
        1 |               |           1 |      3 |      10 | HashJoin       | {5,1}       |               30.5 |              482.1 | 16320 | f      |          |          |              2
        1 |               |           1 |      4 |      11 | HashJoin       | {5,1}       |               30.5 |              482.1 | 16320 | f      |          |          |              0
(11 rows)
```

Описание столбцов таблицы ee.paths можно посмотреть в файле "extended_explain--1.0.sql".

С помощью данного расширения можно увидеть, что планировщик рассматривал 4 варианта сканирования отношения t1, лишь в двух вариантах для сканирования используется индекс. Также можно обратить внимание, что планировщик не рассматривал использование NestLoop соединения. В свою очередь, HashJoin пути показали наихудшую общую стоимость в сравнении с MergeJoin путями. Далее можно заметить, что 7 и 11 пути абсолютно одинаковые -- трактовать это можно следующим образом: 7 план рассматривался во время перебора вариантов соединения, а 11 план -- это наилучший путь для получения результирующего отношения (в данном случае копия 7-го пути).

Информацию из таблицы ee.paths можно по-разному интерпретировать. Примером может послужить тестовый проект [ee_visualizer](https://github.com/04ina/ee_visualizer), визуализирующий пути в удобном для анализа формате.

После исполнения команды в таблицу ee.query добавляется общая информация об исполнении планирования:

```sql
SELECT * FROM ee.query;
 id |        execution_ts        |                            query_text                            
----+----------------------------+------------------------------------------------------------------
  1 | 2025-11-01 17:33:01.978709 | EXPLAIN (get_paths) SELECT * FROM t1 JOIN t2 ON t1.att = t2.att;
(1 row)
```

# Тесты 

Произвести тестирование расширения можно посредством make и meson.

## make
```sh
make installcheck
```    
Если же переменная окружения PATH не определена:
```sh
make PG_CONFIG=postgres_directory/bin/pg_config installcheck
```
## meson 
```sh
cd build
ninja test 
```