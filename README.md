extended_explain -- расширение для СУБД PostgreSQL, позволяющее исследовать все пути (узлы), которые оптимизатор/планировщик перебирает в процессе поиска наилучшего плана исполнения запроса. 

Содержание:

1. [Инсталляция](#инсталляция)
     1. [make](#make)
     2. [meson](#meson)
2. [Примеры использования](#примеры-использования)
3. [Дополнительный материал](#дополнительный-материал)
4. [Тесты](#тесты)

# Инсталляция

Перед инсталляцией необходимо применить патч для postgres-а ветки REL_17_STABLE

```sh
git apply add_path_hook.patch
```

Инсталлировать расширение можно двумя способами: с помощью make и meson.

## make
```sh
make install
```    
Если переменная окружения PATH не определена:
```sh
make PG_CONFIG=postgres_directory/bin/pg_config install
```
## meson 
```sh
meson build
cd build
ninja install
```
Если переменная окружения PATH не определена:
```sh
meson build -Dpg_config=postgres_directory/bin/pg_config
cd build
ninja install
```

### Создание расширения

После инсталляции создаем расширение посредством терминального клиента psql.
```sql
CREATE EXTENSION extended_explain;
```

# Примеры использования

При каждом вызове команды EXPLAIN в таблицу ee.paths будут записываться все пути, которые оптимизатор запросов рассматривал при поиске лучшего плана исполнения SQL запроса.

В качестве примера рассмотрим запрос с соединением двух таблиц t1 и t2, каждая из которых имеет по одному столбцу типа integer. Также на столбец таблицы t1 "навесим" btree индекс.
```sql
CREATE TABLE t1 AS SELECT generate_series(1,1000) AS att;
CREATE INDEX ON t1(att);

CREATE TABLE t2 AS SELECT generate_series(1,10000) att;
```

Выполним команду EXPLAIN для запроса с соединением:

```sql
EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.att = t2.att;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Merge Join  (cost=1369.41..2662.91 rows=81600 width=8)
   Merge Cond: (t1.att = t2.att)
   ->  Index Only Scan using t1_att_idx on t1  (cost=0.28..67.28 rows=1000 width=4)
   ->  Sort  (cost=1369.14..1409.94 rows=16320 width=4)
         Sort Key: t2.att
         ->  Seq Scan on t2  (cost=0.00..227.20 rows=16320 width=4)
```

После завершения исполнения команды все пути сохраняются в таблицу расширения ee.paths:

```sql
SELECT * FROM ee.paths;
 level | path_name |   path_type    | child_paths |    startup_cost    |     total_cost      | rows  | is_del | rel_name | indexoid 
-------+-----------+----------------+-------------+--------------------+---------------------+-------+--------+----------+----------
     1 |         1 | SeqScan        |             |                  0 |                  18 |  1000 | f      | t1       |         
     1 |         2 | IndexOnlyScan  |             |              0.275 |              67.275 |  1000 | f      | t1       |   983506
     1 |         3 | IndexOnlyScan  |             |              0.275 | 0.36568627450980395 |     5 | f      | t1       |   983506
     1 |         4 | BitmapHeapScan |             | 0.3149754901960784 |   4.377475490196078 |     5 | f      | t1       |         
     1 |         5 | SeqScan        |             |                  0 |  227.20000000000002 | 16320 | f      | t2       |         
     2 |         6 | MergeJoin      | {1,5}       |  1436.968161870994 |  2665.9681618709938 | 81600 | f      |          |         
     2 |         7 | MergeJoin      | {2,5}       | 1369.4142404476836 |  2662.9142404476834 | 81600 | f      |          |         
     2 |         8 | HashJoin       | {1,5}       | 431.20000000000005 |              3307.7 | 81600 | f      |          |         
     2 |         9 | MergeJoin      | {5,1}       |  1436.968161870994 |   2742.568161870994 | 81600 | f      |          |         
     2 |        10 | HashJoin       | {5,1}       |               30.5 |              3154.5 | 81600 | f      |          |         
     2 |        11 | MergeJoin      | {2,5}       | 1369.4142404476836 |  2662.9142404476834 | 81600 | f      |          |         
(11 rows)
```
Описание столбцов таблицы ee.paths можно посмотреть в файле "extended_explain--1.0.sql".

С помощью данного расширения можно увидеть, что планировщик рассматривал 4 варианта сканирования отношения t1, лишь в двух вариантах для сканирования используется индекс. Также можно обратить внимание, что планировщик не рассматривал использование NestLoop соединения. В свою очередь, HashJoin пути показали наихудшую общую стоимость в сравнении с MergeJoin путями. Далее можно заметить, что 7 и 11 пути абсолютно одинаковые -- трактовать это можно следующим образом: 7 план рассматривался во время перебора вариантов соединения, а 11 план -- это наилучший путь для получения результирующего отношения (в данном случае копия 7-го пути).

Информацию из таблицы ee.paths можно по-разному интерпретировать. Примером может послужить тестовый проект [pg_path_tree_visualization](https://github.com/04ina/pg_path_tree_visualization), визуализирующий пути в виде дерева.

# Дополнительный материал

* [Демонстрационный ролик](https://rutube.ru/video/private/69afe214c5b051d23f302c2742d8cb43/?p=Kl6r1nZqvODlZ0IUxboPXw)

# Тесты 